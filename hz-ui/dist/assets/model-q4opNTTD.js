import{cG as A,g as I,r as i,v as r,ch as R}from"./index-D37lWo2y.js";const x=A("modelConfigs",()=>{const{proxy:c}=I(),t=i([]),f=r(()=>t.value.reduce((e,a)=>(e[a.name]=a,e),{})),g=r(()=>t.value.reduce((e,a)=>(e[a.id]=a,e),{})),y=r(()=>t.value.map(e=>({label:e.verbose_name,value:e.id}))),b=e=>{t.value=e},d=async(e=!1)=>{if(!e&&t.value.length>0)return;let a=await c.$api.getCiModel();t.value=a.data.results},l=i([]),O=r(()=>l.value.map(e=>({label:e.verbose_name,name:e.name,type:e.type,value:e.id}))),m=r(()=>l.value.reduce((e,a)=>(e[a.id]=a,e),{})),h=r(()=>l.value.filter(e=>e.type==="enum").reduce((e,a)=>{try{let n=JSON.parse(a.rule),u=[];Object.keys(n).forEach(o=>{u.push({value:o,label:n[o]})}),e[a.id]=u}catch(n){console.warn("Failed to parse rule for item:",a.id,n)}return e},{})),M=e=>{l.value=e},j=async(e=!1)=>{if(!e&&l.value.length>0)return;let a=await c.$api.getValidationRules({page_size:2e3,page:1});l.value=a.data.results},v=e=>{let a=[];return e.instances&&Array.isArray(e.instances)&&(a=a.concat(e.instances)),e.children&&Array.isArray(e.children)&&e.children.forEach(n=>{a=a.concat(v(n))}),a},s=i({}),C=r(()=>{let e={};return Object.keys(s.value).forEach(a=>{let n=s.value[a],u=v(n);e[a]=u.map(o=>({value:o.id,label:o.instance_name}))}),e}),p=async e=>{let a=await R.getCiModelTreeNode({model:e});s.value[e]=a.data[0],console.log(s.value[e])};return{allModels:t,modelObjectByName:f,modelObjectById:g,modelOptions:y,getModel:d,updateAllModels:b,allModelCiDataObj:s,getModelTreeInstance:p,getAllModelTreeInstances:async(e=!1)=>{t.value.length==0&&await d(),t.value.forEach(async a=>{!e&&Object.keys(s.value).indexOf(a.id)!==-1||await p(a.id)})},allModelCiDataTreeObj:C,validationRules:l,validationRulesObjectById:m,validationRulesEnumOptionsObject:h,getValidationRules:j,updateValidationRules:M,validationRulesOptions:O,clearModelConfig:()=>{s.value={},l.value=[],t.value=[]}}},{persist:!0});export{x as m};
