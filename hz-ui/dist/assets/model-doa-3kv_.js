import{cG as C,g as I,r as i,v as s,ch as R}from"./index-CWdEKdsq.js";const T=C("modelConfigs",()=>{const{proxy:c}=I(),t=i([]),f=s(()=>t.value.reduce((e,a)=>(e[a.name]=a,e),{})),y=s(()=>t.value.reduce((e,a)=>(e[a.id]=a,e),{})),g=s(()=>t.value.map(e=>({label:e.verbose_name,value:e.id}))),b=e=>{t.value=e},d=async(e=!1)=>{if(!e&&t.value.length>0)return;let a=await c.$api.getCiModel();t.value=a.data.results},n=i([]),m=s(()=>n.value.map(e=>({label:e.verbose_name,name:e.name,type:e.type,value:e.id}))),O=s(()=>n.value.reduce((e,a)=>(e[a.id]=a,e),{})),h=s(()=>n.value.filter(e=>e.type==="enum").reduce((e,a)=>{try{let l=JSON.parse(a.rule),u=[];Object.keys(l).forEach(o=>{u.push({value:o,label:l[o]})}),e[a.id]=u}catch(l){console.warn("Failed to parse rule for item:",a.id,l)}return e},{})),j=e=>{n.value=e},M=async(e=!1)=>{if(!e&&n.value.length>0)return;let a=await c.$api.getValidationRules({page_size:2e3,page:1});n.value=a.data.results},v=e=>{let a=[];return e.instances&&Array.isArray(e.instances)&&(a=a.concat(e.instances)),e.children&&Array.isArray(e.children)&&e.children.forEach(l=>{a=a.concat(v(l))}),a},r=i({}),A=s(()=>{let e={};return Object.keys(r.value).forEach(a=>{let l=r.value[a],u=v(l);e[a]=u.map(o=>({value:o.id,label:o.instance_name}))}),e}),p=async e=>{let a=await R.getCiModelTreeNode({model:e});r.value[e]=a.data[0],console.log(r.value[e])};return{allModels:t,modelObjectByName:f,modelObjectById:y,modelOptions:g,getModel:d,updateAllModels:b,allModelCiDataObj:r,getModelTreeInstance:p,getAllModelTreeInstances:async(e=!1)=>{!e&&Object.keys(r.value).length>0||(t.value.length==0&&await d(),t.value.forEach(async a=>{await p(a.id)}))},allModelCiDataTreeObj:A,validationRules:n,validationRulesObjectById:O,validationRulesEnumOptionsObject:h,getValidationRules:M,updateValidationRules:j,validationRulesOptions:m}},{persist:!0});export{T as m};
